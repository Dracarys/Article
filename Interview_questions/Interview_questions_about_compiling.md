# 面试题系列之编译

## 1. 编译
 编译是指将程序从源文件转为机器可执行的二进制文件的过程，那么这个过程是什么样的呢？为什么要了解编译的过程呢？

### 1.1 编译的过程
假设我们有现有这样一个源文件 "hello.c"：

```c
#include <stdio.h>

int main() {
	printf("Hello, world!");
	return 0;
}
```
其编译的大致过程如下：

```shell
 hello.c             hello.i             hello.s              hello.o               hello
---------> 预处理器 -------------> 编译器 ---------> 汇编器 ---------------> 链接器 ------------->
 源程序文件          修改了的源程序          汇编程序         可重定位的目标程序         可执行目标程序
```

下面简单介绍一下各个步骤：

1. 预处理阶段。处理一些符号，例如：#define 的宏、#import，以及其它与处理指令。该过程会输出以 ".i"(C)，".ii"  (C++), ".mi" (Objective-C), 以及 ".mii" (Objective-C++) 为扩展名的文件。
2. 编译阶段。编译器将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。该阶段还可以被细分为词法分析和语法分析以及代码生成和优化四个子阶段。
3. 汇编阶段。汇编器将 hello.s 翻译成机器语言指令，把这些指令打包成一种极哦啊做可重定位目标程序等格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件。
4. 链接阶段。将目标文件中的符号链接到地址，或者将不能连接到错误反馈给用户。

这只是编译的一个大致过程，每一步都有专门的程序负责，因此通常在最开始还会有一个“驱动”，负责将各个子过程串接起来。此外编译阶段和汇编阶段还可以继续细分：

1. 词法分析（lexical analysis）。词法分析器读入组成元程序的字符流，并将他们组织成为有意义的词素（lexeme）的序列。对于每个词素，词法分析器产生如下形式的词法单元（token）作为输出：`<token-name, attribute-value>`。
2. 语法分析（sytax analysis）。语法分析器是用有词法分析器生成的各个词法但愿你的第一个分量来创建属性的中间表示。该中间表示给出来词法分析产生的词法单元流的语法结构。一个常用的白哦时方法是语法树（syntax tree），书中的每个内容结点表示一个运算，而该结点的子结点表示该运算的分量。
3. 语义分析（semantic analyzer）。使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。它同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在会后的中间代码生成过程中使用。
4. 中间代码生成器。中间表示形式
5. 机器无关代码优化器。中间表示形式
6. 代码生成器。目标机器语言
7. 机器相关代码优化器。目标机器语言

参考：
 
 - 《深入理解计算机系统》第三版
 - 《计算机编译原理》 

### 1.2 介绍一下 Clang 和 LLVM
LLVM（Low Level Virtual Machine）是一个开源的编译器架构。

Clang (发音为/klæŋ/)是 LLVM 的一个编译器前端，它目前支持 C、C++、Objective-C、Objective-C++。Clang 对原程序进行预处理、词法分析和语义分析（参照上一问题了解全过程），并将分析结果转换为抽象语法树（Abstract Syntax Tree），最后使用 LLVM 作为后端代码的生成器。

#### 1.2.1 Clang 的开发背景
由于 GNU 编译器套装 (GCC) 系统庞大，而且 Apple 大量使用的 Objective-C 在 GCC 中优先级较低，同时 GCC 作为一个纯粹的编译系统，与 IDE 配合并不优秀，Apple 决定从零开始写 C family 的前端，也就是基于 LLVM 的 Clang 了。Clang 由 Apple 公司开发，源代码授权使用 BSD 的开源授权

#### 1.2.2 Clang 的特性
相比于 GCC，Clang 具有如下优点：

- 编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。
- 占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。
- 模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。
- 诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。
- 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。


#### static 关键字的作用
声明为静态，会被编译到静态区，为可见者全局共享。

### define 与 static 的 区别

- define 定义的内容会在预编译期被预处理器替换掉
- static 会被编译到静态区，且可见者全局共享。

### #import"" 和 #import<> 区别，还有#inlcude
`#import` 和 `#include` 的区别，前者可以避免重复引用，后者则不具备此功能，因此推荐使用前者。

- `#import ""` 优先搜索本地路径，如果找不到在搜索系统头文件路径检索
- `#import <>` 直接到系统路头文件路径检索

### 如何防止别人反编译你的 App？
除了一些本地数据加密，地址哈希，网络传输加密再没有其它的反编译经验，只能说一些耳闻的内容：

1. 本地数据加密。对于存储在手机上的本地数据进行加密处理。如：NSUserDefaults，SQLite 的数据库文件，数据库不存储明文内容，将核心内容存储到 keychain等。
2. URL 编码加密。对程序中出现的URL进行编码加密，防止URL被静态分析
3. 网络传输数据加密。对通过网络传输的数据进行加密，如：启用HTTPS，进行双向验证等。
4. 方法体、方法名高级混淆。对方法名和方法体进行混淆，保证源码被逆向后无法解析代码。
5. 程序结构混排加密。对应用逻辑结构进行打乱混排，降低逆向后的可读性。

### 静态语言和动态语言的区别
主要区别就在链接：

- 静态语言编译后地址都是相对固定的，没有运行期解析的过程，相对更效率
- 动态语言编译后的地址是动态的，要到运行期才能确定，相对更灵活 

### 静态库和动态库之间的区别
- 动态库 \*.dylib 和 \*.framework，连接时不复制，程序运行时由系统动态加载到内存，
- 静态库 \*.a 和 \*.framework。连接时，静态会被复制到输出目标中

### iOS从什么时候开始支持动态库的？
Xcode 6 之后支持创建动态库工程。

## Xcode

### OtherLinkFlag 解决命名冲突。

- Objc
- all_load
- force_load