# 面试题系列之编译

### 编译过程，如何从源文件转为二进制文件

以 hello.c 源文件为例，编译的大致过程如下：

```shell
 hello.c             hello.i             hello.s              hello.o               hello
---------> 预处理器 -------------> 编译器 ---------> 汇编器 ---------------> 链接器 ------------->
 源程序文件          修改了的源程序          汇编程序         可重定位的目标程序         可执行目标程序
```

下面简单介绍一下各个步骤：

1. 预处理阶段。预处理器根据字符 # 开头的命令，修改原是的 C 程序。例如宏替换，引用等；
2. 编译阶段。编译器将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。
3. 汇编阶段。汇编器将 hello.s 翻译成机器语言指令，把这些指令打包成一种极哦啊做可重定位目标程序等格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件。
4. 链接阶段。将目标文件中的符号链接到地址，或者将不能连接到错误反馈给用户。

这只是一个大致的步骤，编译阶段还可以继续细分：

1. 词法分析（lexical analysis）。词法分析器读入组成元程序的字符流，并将他们组织成为有意义的词素（lexeme）的序列。对于每个词素，词法分析器产生如下形式的词法单元（token）作为输出：`<token-name, attribute-value>`。
2. 语法分析（sytax analysis）。语法分析器是用有词法分析器生成的各个词法但愿你的第一个分量来创建属性的中间表示。该中间表示给出来词法分析产生的词法单元流的语法结构。一个常用的白哦时方法是语法树（syntax tree），书中的每个内容结点表示一个运算，而该结点的子结点表示该运算的分量。
3. 语义分析（semantic analyzer）。使用语法树和符号表中的信息来检查源程序是否和语言定义的语义一致。它同时也收集类型信息，并把这些信息存放在语法树或符号表中，以便在会后的中间代码生成过程中使用。
4. 中间代码生成器。中间表示形式
5. 机器无关代码优化器。中间表示形式
6. 代码生成器。目标机器语言
7. 机器相关代码优化器。目标机器语言

#### 以 Clang、LLVM 为例简述一下编译过程

#### static 关键字的作用

声明为静态，会被编译到静态区，为可见者全局共享。

### define 与 static的 区别

- define 定义的内容会在预编译期被预处理器替换掉
- static 会被编译到静态区，且可见者全局共享。

### #import"" 和 #import<> 区别，还有#inlcude
`#import` 和 `#include` 的区别，前者可以避免重复引用，后者则不具备此功能，因此推荐使用前者。

- `#import ""` 用来应用自己生成的头文件
- `#import <>` 引用系统的自有库的头文件

### 如何防止别人反编译你的 App？

除了一些本地数据加密，地址哈希，网络传输加密再没有其它的反编译经验，只能说一些耳闻的内容：

1. 本地数据加密。对于存储在手机上的本地数据进行加密处理。如：NSUserDefaults，SQLite 的数据库文件，数据库不存储明文内容，将核心内容存储到 keychain等。
2. URL 编码加密。对程序中出现的URL进行编码加密，防止URL被静态分析
3. 网络传输数据加密。对通过网络传输的数据进行加密，如：启用HTTPS，进行双向验证等。
4. 方法体、方法名高级混淆。对方法名和方法体进行混淆，保证源码被逆向后无法解析代码。
5. 程序结构混排加密。对应用逻辑结构进行打乱混排，降低逆向后的可读性。

### 静态语言和动态语言的区别

主要区别就在链接：

- 静态语言编译后地址都是相对固定的，没有运行期解析的过程，相对更效率
- 动态语言编译后的地址是动态的，要到运行期才能确定，相对更灵活 