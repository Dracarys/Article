# 面试题系列之操作系统

### 1. 堆和栈的区别，为什么要分堆和栈？如何优化？那种会造成内存碎片化？
- 栈区(stack)由编译器自动分配释放 ,存放方法(函数)的参数值, 局部变量的值等，栈是向低地址扩展的数据结构，是一块连续的内存的区域。即栈顶的地址和栈的最大容量是系统预先规定好的。

- 堆区(heap)一般由程序员分配释放, 若程序员不释放,程序结束时由OS回收，向高地址扩展的数据结构，是不连续的内存区域，从而堆获得的空间比较灵活。

- 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出.

- 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。

- 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。

- 全局区(静态区)(static),全局变量和静态变量的存储是放在一块 的,初始化的全局变量和静态变量在一块区域, 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放。

- 文字常量区—常量字符串就是放在这里的。程序结束后由系统释放。

- 程序代码区—存放函数体的二进制代码

### 2. 线程和进程的区别，内存共享、进程买哦树、写时复制、操作系统启动《深入理解计算机系统》

-  一个程序至少要有进城,一个进程至少要有一个线程.
进程:资源分配的最小独立单元,进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
- 线程:进程下的一个分支,是进程的实体,是CPU调度和分派的基本单元,它是比进程更小的能独立运行的基本单位,线程自己基本不拥有系统资源,只拥有一点在运行中必不可少的资源(程序计数器、一组寄存器、栈)，但是它可与同属一个进程的其他线程共享进程所拥有的全部资源。
- 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。
- 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。
- 但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

### 3. 静态常量区访问的过程

### 4. 进程间如何通信，方式有哪些？
每个进程各自有不同的用户地址空间,任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核,在内核中开辟一块缓冲区,进程A把数据从用户空间拷到内核缓冲区,进程B再从内核缓冲区把数据读走,内核提供的这种机制称为进程间通信

#### 4.1 匿名管道通信（pipe）
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系（父子进程）的进程间进行。

步骤如下：

- 父进程创建管道，得到2个文件描述符指向管道的两端
- 父进程 fork 出子进程，子进程也有2个文件描述符指向同一个管道
- 父进程关闭 fd[0]，子进程关闭 fd[1]，因为是单向通信，所以父进程关闭读段，子进程关闭写端。

#### 4.2 高级管道通信
高级管道（popen）：将另一个程序当作一个新的进程在当前程序进程中启动，则它算作当前程序的子进程，这种方式称为高级管道方式。

#### 4.3 有名管道通信
有名管道（named pipe）：又名管道也是半双工的通信方式，但它允许无亲缘关系进程间通信。

#### 4.4 消息队列通信
消息队列（message queue）：消息队列是有消息的链表，存放在内核中并由消息队列标识标识。消息队列克服了信号传递信息少、管道只能承载物格式字节流以及缓冲区大小受限等缺点；

#### 4.5 信号量通信
信号量（semophore）：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止其它进程正在访问资源时，其它进程也访问该资源。因此主要作为进程间以及同一进程不同线程间的同步手段。

#### 4.6 信号
信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生

#### 4.7 共享内存通信
共享内存（memory shared）：共享内存就是映射一段能被其它进程所为访问的内存，这段共享内存由一个进程创建，但可由多个进程访问。共享内存是最快的 IPC 方式，它是针对其它进程间通信运行效率低而设计的。它往往与其它通信机制，如信号量，配合使用，来实现进程间的同步和通信。

#### 4.8 Socket
与其它方式不同的是，它可以用于不同主机之间的进程间通信。

### 5. 两个进程分别指向同一个地址空间并初始化一个值，分别输出什么？

### 6. 程序执行的过程

1. 父进程 fork 成一个子进程；
2. 子进程启动加载器；
3. 加载器（Dyld）删除子进程现有的虚拟内存段，并创建出一套新的虚拟内存段，也就是代码区、数据区、堆区、共享库区、栈区等；
4. 通过虚拟地址空间中的页映射到可执行文件到页大小的片（chunk），代码区、数据区初始化为可执行文件的内容；
5. 通过head取得依赖的共享列表，解析，递归加载有依赖的动态库，Rebasing and binding、
6. 加载完毕，通知 Objc runtime，运行时开始加载类、扩展并将他们连接起来
7. C++ generates intializer for staticlly allocated objects
8. Objc +load methods
9. Run "bottom up" so each initializer can call dylibs below it
10. lastly, Dyld calls main() in excutable

简化版：

1. Parse images
2. Map images
3. Rebase images
4. Bind images
5. Run image initializers
6. Call main()
7. Call UIApplicationMain()

测试分析启动过程可以用到 DYLD_PRINT_STATISTICS 环境变量，scheme 的运行中添加。

一个应用通常有100到400个动态链接库

优化方法：

1. 优化加载时间：合并静态、静态库，可以提高加载速度；
2. Rebase/Binding：缩减 __DATA 指针；缩减 Objc 元数据，如：Clases、selectors、categories；缩减 C++ 虚函数；采用 SWift 结构；严格测试机器自动生成的代码，用偏移量代替指针，标记为只读；总之减少不必要的类，越多越慢；
3. 运行时：跟2中提到的优化点相同。
4. Initializers: 尽量用 +initialize 代替 +load；Replace C/C++ `__attribute__((constructor))` with call site initializers。例如：`dispatch_once()`、`pthread_once()`、`std::once()`；或者该用 Swift，就没这些烦恼了；不要在初始化函数中调用 dlopen() 和开辟线程。

简化版：

1. 减少动态库；
2. 缩减 Objc 类；
3. 淘汰静态初始化；
4. 多用 Swift

### 一个进程有哪些区

代码区、数据区(只读、可读写)、堆区、共享库、栈区、

### 内核态和用户态的区别，为什么要这样分
为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

### 为什么要有page cache，操作系统怎么设计的Page cache

为什么要设计 page cache，这是因为随着计算的发展，CPU、RAM 和 磁盘之间的速度差异越拉越大，已经到了指数级别，为了提高总体上的运行效率，避免快等慢等问题。才推出了 Page cache。

对于系统的所有文件I/O请求，操作系统都是通过page cache机制实现的，对于操作系统而言，磁盘文件都是由一系列的数据块顺序组成，数据块的大小随系统不同而不同，x86 linux系统下是4KB(一个标准页面大小)。内核在处理文件I/O请求时，首先到page cache中查找(page cache中的每一个数据块都设置了文件以及偏移信息)，如果未命中，则启动磁盘I/O，将磁盘文件中的数据块加载到page cache中的一个空闲块。之后再copy到用户缓冲区中。

参考：《深入理解计算机系统》第9章 虚拟内存

### 介绍 5 种IO模型

- 阻塞 I/O （blocking I/O）
- 非阻塞 I/O （nonblocking I/O）
- I/O 复用
- 信号驱动 I/O
- 异步 I/O

[5 种网络 I/O 模型](https://www.cnblogs.com/findumars/p/6361627.html)

### 异步编程的时间循环

### 项目采用64位，为什么用64位，怎么修改成64位，i386又是指什么，他们之间什么关系

计算机处理器的位数是由通用寄存器的宽度定义的，一般说的32位和64位指的是处理器的位宽，即通用寄存器的宽度。和32位的处理器相比，64位处理的优势在与能够处理更长的指令，在运行64位指令时效率更高。

不需要特别的修改，但需要注意代码中使用的数据类型，尽量使用基于平台的类型，而不是指定的特殊类型。

i386 指的是 Intel 386，也泛指 IA32 体系的 CPU。在 iOS 开发过程中通常是指针对模拟器编译的包或库。
