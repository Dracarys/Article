# 【笔记】如何选择锁

上一篇介绍了各种锁，并简单阐述了各种锁的特点及其实现。那么在实际开发的过程中，如何选择恰当的锁呢？

## 选择标准
总结起来，选择标准就两点：

1. 不能造成死锁
2. 尽量追求高性能

## 避免死锁
造成死锁的四个条件，相比大家都耳熟能详：

1. 条件互斥
2. 占有和等待条件
3. 不可抢占条件
4. 环路等待条件

为了避免死锁，我们通常会用：**层次锁（hierarchical locking）** ，在多个相关联的锁上规定一个顺序，要求所有的线程都以相同的顺序加锁，以此来避免死锁的发生。

但是在有些场景下，我们必须违反加锁顺序。考虑一下场景，有一个以双向链表实现，支持 LRU 算法的缓存。它通过自旋锁来保护队列头部和队列中缓冲对象的前后向指针。每个缓冲对象还存在一个自旋锁用来保护对象自身信息。当访问这个对象时，这个锁必须被持有。

当某个线程想要访问某个特定的缓冲对象时，显示通过哈希表（也可能是其它方式）定位到对象，然后加锁。如果要进一步从缓存列表中删除该对象，还需对链表加锁。所以加锁的顺序是先缓存对象，后缓存列表。

然而有时候，线程需要获取一个空缓存对象，然后在填充内容，在那么此时就是先锁住缓存列表，然后在锁住列表上的首个缓存对象。此时的顺序就变成了先锁列表，在锁缓存对象。

如果此时有两个线程，分别以这两种顺序进行加锁，那么就可能出现双方都锁住了部分资源，又都等待对方释放自己所需资源的情况，从而发生死锁。

为了避免此情况，此时就应该使用：**随机锁（stochastic locking）**，当某个线程尝试获取一个可能会破坏层次的锁时，可以使用try_lock()来代替lock()操作，尝试获取锁，如果锁已经被持有，它会返回失败，而不是阻塞在这个锁上。在上面的例子中，尝试获取一个空缓存对象的线程会先锁住列表，然后沿着列表，使用 `try_lock()`，直至找到一个可以锁住的缓冲区。

一个自旋锁的 `try_lock()` 实现：

```C
int try_lock(spinlock *s) {
    if(test_and_set(s) != 0)
        return false;
    else
        return true;
}
```

### 递归锁
当一个线程需要获取自己已经拥有的锁时，那么我们就必须使用递归锁，否则将造成死锁。

### 阻塞还是自旋
大多数复杂的锁都可以被实现为阻塞锁，或者复杂的自旋锁，而不影响其功能。此时选择阻塞还是自旋就要从性能上进行考量了。

因为忙等会占用处理器，一般不怎么受待见。但是，一些特殊场景却必须使用忙等。例如，线程已经有一个简单的互斥锁，那么它就不能被阻塞，因为它还要负责唤醒被它所持有的互斥锁阻塞的线程。此时如果它尝试获取另一个简单的互斥锁，它将进入忙等；如果它试图获取一个复杂锁，那么它会释放它已经持有的互斥锁。

但是我们还要考虑到一个问题，就是因为阻塞而带来的睡眠和唤醒是开销很大的操作，它包括了每次结束时的上下文切换，以及睡眠队列和调度器队列的操作。所以对那些很快就可用的资源使用阻塞锁显然是不够效率的。

此外，一些资源是被短时间占用，还是长时间持有，是需要视具体情况。例如，当我们操作内存缓存的时候，很快即可操作完毕；但是当从内存向磁盘同步时，就可能需要较长的时间。面对这种情况时，如果单独使用自旋或者阻塞，都不能算是一个很好的方案。一个可选的方法是提供两种锁。

### 锁对象


### 粒度和持续时间

此外还需要考虑锁的持续时间。持有锁的时间越短越好，这样减少能极少锁上的竞争。然而，有时候，这可能导致额外的加锁和解锁。例如，某个线程需要在一个对象上执行两个操作，这两个操作都需要锁住对象。而两个操作之间，线程还需要执行一些额外不相关的任务。那么它就可能在第一个操作之后对该对象解锁，然后在第二次操作时再加锁。实际上，如果这个不相关的任务非常短暂，保持一直加锁的状态可能会更好，可以省去一次加解锁的开销。

### 最后
本人一直从事客户端开发，涉及到锁，尤其是复杂锁的应用场景接触的并不多。工作中遇到的一些问题，几乎都可以通过 Google 来解决。但是慢慢发现一个问题，大家都在介绍锁，怎么用锁，但很少有文章设计如何选择锁。恰好最近在翻阅《深入理解 UNIX 系统内核》这本书，算是解决了心中的部分疑惑，遂总结了这篇笔记。


### 参考

- 《深入理解 UNIX 系统内核》 Uresh Vahalia 著， 李雨、薛磊、黄庆新 译
